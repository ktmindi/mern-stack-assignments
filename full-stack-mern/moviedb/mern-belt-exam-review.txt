9-29-22 Full-Stack Day1: Back-End

// a lot of the server code will be very similar so its recommended that we set this up before our exam begins..

1. Create a project folder with the name lowercaseThenUpperCaseTheRest?

2. Inside the MAIN project folder create two more folders and a server.js file
	>> Server	>> Client	>> server.js

3. Inside the Server folder create four more folders
	>> config	>> controllers  	>> models	  >> routes	

4. Inside the SERVER folder run [npm init -y] to create your package.json file 
	// this file must be created first because it will keep track of all the dependencies and packages that we install that our project needs

5. While still inside the SERVER folder we need to install two dependencies we know we will need. Express mongoose and cors. [npm i express mongoose cors] 
	//remember we can install as many packages as we want in one line we just need to put a space between the packages and we can use "I" instead of writing install every time
	//when you open up your package.json file you should now see express and mongoose in there 
	// you will also see that we now have a node_module folder inside our server folder. [[remember you will also have a node_module folder inside your client folder]] -- because these folders are super large. When we are exporting to GitHub we want to consider putting this file into our gitignore file but that is a discussion we will later circle back around too
//we forgot about cors till we were half way thru the part 2 video of front end. cors allows for the front end and back end to talk to eachother 

6. Now we will go into our server.js FILE and start writing out required code the first being to import our express app
	const express = require('express') // require == import ;; on our client(react) side we will be using import and on our server side we will be using require but they essentially mean the same thing and are used to import required packages/dependencies that we have
	const app = express() //turn this into app which is running Express
	const PORT = 8000 //set up a port

	app.use(express.json()) //this is called middleware.. we need this middleware for our POST route so this allows for when we send a post request the data is getting added into the request ...
	app.use(express.urlencoded({extended:true}) //...and extended equals true is allowing us to send and process nested data -- so if we are sending an object with our post request that has nested data like an array of objects with an array of objects in it this is an extra option that makes all of that work

	\\Middleware for formatting and allowing POST request//

	app.listen(PORT, ()=>    //this runs our application by taking two things in = the port and a callback function. 


7. Now we will go into our configuration folder and create a file named
	>> mongoose.config.js
   This file is for? Connecting to mongodb with mongoose -- but we are connecting it to our application

8. Inside our mongoose.config.js file we need to first import mongoose
	const mongoose = require('mongoose')

	mongoose.connect('mongoose://localhost/moviedb') //we use this line of code to connect our app with our db. We need to input the name of our db here -- because this is a PROMISE..asynchronous.. we want to handle diff cases - what happens if we get a good response and what happens if we get a bad response


//we can pass in options for this request what are they? useNewUrl and useUnified
//just a common convention a lot of functions will have like here.. (mongodb://localhost/moviedb)is where this function is going or connecting or whatever its doing.. and the second option can be an object with additional options (useNew useUnified)

	mongoose.connect('mongodb://localhost/moviedb', {
    		useNewUrlParser:true, 
    		useUnifiedTopology:true
	})
	.then(()=>{
    		console.log("Connected to Movie DB")
	}).catch((err)=>{
    		console.log(err)
	})


9. Now we need a schema and a model so in our models folder we need to create a file named 
	>> movie.model.js
 
	const mongoose = require('mongoose') //import mongoose again

	now we have to create a schema first - then turn it into a model - and when we make it into a model what else does it turn into at the same time ? - a collection

	const MovieSchema = mongoose.Schema()
	const MovieSchema = new mongoose.Schema() [we can also add in the word new]

	//what do we pass into this function? An object - a schema is an object thats just saying what format the data is going to take

	//we want to add complexity and extra things about our fields in our model that are going to interact with out front end and we will see that next week.

	//If we are doing multiple things with this field besides just specifying the type then we pass an object to that field and then the first argument will be type string and then we can add any other options underneath it..  

//we can store an image for the poster of the movie by storing the http image source from the internet. So we would put boxArt: String 
//if we want to store a date we can store it as a string and format it later.

//when we pass in the option timestamps:true at the end.. this means that anytime we go to add a new movie -- besides getting an ID it will also automatically get a created at and updated at field which is 

//lastly we need to.. turn it into a model using .. 
Const Movie = mongoose.model(two arguments here that HAVE to be in the correct order)
1st == singular version of the collection name -- name that we are essentially giving the model and the collection in the database  
2nd == the blueprint / what structure we are using == MovieSchema

 Then we need to export it
	module.exports = Movie

//TO TEST WE CAN USE POSTMAN -- ONCE WE SET UP ROUTES.


10. Next we should create ROUTES (before controllers) but before we can do this.. we need to create a file inside our controllers folder named 
	>>movie.controllers.js 
Then Inside our routes folder create a file named
	>> movie.routes.js 
To set up the routes file we need to first import controllers using
	const MovieController = require('../controllers/movie.controlers')
We do this so we can connect the two files. So we can connect our route to the correct controller function.

Now we do module.exports = (app) => {}  // module.exports is a function that will take in app 
// app is our Express
Remember that module.exports is the function that we use to export things in files so we can use them elsewhere by importing in other places.

// now we have to specify our routes. Every app will have very similar functions based on CRUD functions. So what are some routes we will want? 

	module.exports = (app) => {
    		//GET ALL MOVIES

    		//GET ONE MOVIE
    		//CREATE NEW MOVIE
    		//UPDATE MOVIE
    		//DELETE MOVIE
	}

// these are the basic functionalities that we will see repeatedly on many apps. 

// always make sure you start with a slash when you write out routes esp for the server side routes. The other kind of routes that we have are front end routes/client routes -- what tool do we use to define client-side routes? "React rather"

//app.get('/api/allMovies',) <-- theres a second piece here..why? Because its a function -- so why dont we write ../allMovies',()=>{}) ? Because we want to separate responsibilities into different/separate files


//. app.get('/api/allMovies',MovieController.getMovies)
				//we write MovieController because that is the file we have imported that will hold our functions. So first we reference the file = MovieController and then call on a function that we will write(have not written yet) 
So we will actually have to declare that function but we will get there


// our next route that we need to write out is our get one movie route
	app.get('/api/movie/:id')
		//:id -- this is called a path variable or a parameter
	// here we will essentially pull the path variable out of the URL and use it to grab the specific data that correlates with that path variable from the DB and 

const MovieController = require('../controllers/movie.controllers')

	module.exports = (app) => {
    		//GET ALL MOVIES
    		app.get('/api/allMovies',MovieController.getMovies)
    		//GET ONE MOVIE
    		app.get('/api/movie/:id',MovieController.getOneMovie)
    		//CREATE NEW MOVIE -- we know that on the front end we will most likely be using a form to input data into our DB so keeping that in mind how do we write the route?
    		app.post('/api/addMovie', MovieController.addMovie)
    		//UPDATE MOVIE
    		app.put('/api/update/:id', MovieController.updateMovie)
    		//DELETE MOVIE
    		app.delete('/api/delete/:id',MovieController.deleteMovie)
	}


11. Now that we have all the routes set up. We need to set up our controllers - we have all these routes theres a path and it says we run these functions but we haven't defined them yet so lets go and define the functions 

Go to our movie.controllers.js file and first thing we need to do is? IMPORT THE MODEL
	Why? Cuz were going to be using that model to specify what we're going to be doing to the database from these functions 

	const Movie = require('../models/movie.model

//so Movie is referring to the collection in the database and we're running mongoose functions on the collection so that we can add, update, delete, and read movies in that collection

//there are different ways you can structure the module.exports set up. 
	In the previous lecture I show you guys how to do it where it was kind of like each function was like this
	const myFunction = 

	and at the end I did 

	module.exports = {
		myFunction <-- and I passed in all of my exports here
	}

//in the platform they showed you a way where it was like this
	module.exports = (req, res) <-- so there would be multiple module.exports on the screen


But another way we can do it is .. 

	model.exports = {
		getAllMovies:(req, res)=> {
			Movie.find()
			.then((result)=>{
				res.json()           //we need this res.json line of code because whatever you grab from the query needs to be converted to a JSON file in order for it to display in the front end.
			}).catch((err)=>{
				console.log(err)
			})
		},
		getOneMovie:(req, res)=> {
		
		},
		addMovie:(req, res)=> {
		
		},
		updateMovie:(req, res)=> {
		
		},
		deleteMovie:(req, res)=> {
		
		},
	}

	like this where each of the functions will be their own key value pair



Always remember that for this code we need the underscore because we need to specify which field on the model we're looking for so we're saying we're looking for a field where the ID equals {_id:req.params.id}) 

	// why do we have access to this req.params.id? Where does it come from?
	its from the path variable .. anytime we use a colon in one of our routes we automatically have access to this req.params.id on the request object inside of a field called params and whatever we called it colon ID is going to be a called ID in that object

	updateMovie:(req,res)=>{
        	Movie.updateOne({_id:req.params.id})
        	.then((result)=>{
            		res.json()
       		}).catch((err)=>{
            		console.log(err)
        }) //we will make these more complex over time.. but more often then most this is adequate
    },

		// we also have to add what we are updating the movie with to this function



	Movie.updateOne({_id:req.params.id}) so we're going to update one we're which one were updating and then we have to specify rec.body because that is the data we're passing to updates 


	Movie.updateOne({_id:req.params.id}, req.body) 




12. Once we have all of our routes set up - our model - controller - and our connection we need to 

	IMPORT your CONFIG into server.js file 

	IMPORT your ROUTES into server.js file


Now we can run this and see if it works by testing the db using postman.
To test this. Cd into the folder that has server.js inside of it and run using

	nodemon server.js

	//It should say server is up on port 8000
	  connected to Movie DB

13. Open Postman to test out our DB 
	// at the top thre is a plus sign next to a tab titled overview click it
	//change the drop down from GET to POST 
	// enter request URL 
		localhost:8000/api/addMovie
	// underneath the space for URL there is a navibar starting with params -
		click body >> raw >> and at the end change text in the drop down menu to JSON and begin typing out test data

	{
   		"title":"King Kong",
    		"director":"Peter Jackson",
    		"rating":"PG-13",
    		"genre":"Documentary",
    		"releaseYear":"2005",
    		"duration":"2 hours",
    		"boxArt":"url for an image that we can use on the front end"
	}
	
	// once completed click send

	// to check if the data was submitted we can open up mongoosedb compass 
		>> go to left side bar and under databases you should see the name of your database that you declared in the mongoose.config.js file in our case it should say moviedb
	mongoose.connect('mongodb://localhost/moviedb' 
	>> click on it >> a drop down menu appears with a folder titled movies >> open that >> and by default you should be at documents and should see your entry there



	// now to test the other routes we would copy the id between the '  ' 
		_id:ObjectId('63490a2869e190cb6c27d26c')

	// in postman change the POST drop down menu to GETT and enter the following code into the space next to the GET drop down and click send.
		localhost:8000/api/movie/63490a2869e190cb6c27d26c
	// we should now see the post we inserted into the table in the text box at the bottom. 

	// now to try the update movie function. 
		PUT in drop down menu >> url should be localhost:8000/api/update/63490a2869e190cb6c27d26c


___________________________________________________________________________________________

10-04-22 Full-Stack Day2: Back-End

1. Previously we created a folder called client in our project folder. Now we need to turn it into a react app. To do this we will cd into the main app folder where the server and client folders live. 
	>> Inside the terminal run npx create-react-app client 
	since the folder is already created, all the required files will populate inside that folder

We use axios to make request from one location to another
reactor-router-dom will (give us our routing functionality) allow us to be able to determine which components get shown on the screen depending on the route 

	>> cd client
	>> npm i axios react-router-dom


2. what do i need to import from react router dom to set up my router?
	in the app.js file at the top 
	import {BrowserRouter, Routes, Route} from 'react-router-dom';

>> then in the body of the function app between div we need to add all three
	<BrowserRouter>
		<Routes>
			<Route/>
		</Routes>
	</BrowserRouter>

so now we have our server done we can start building components 
	>> create a components folder inside the src folder 

3. The first component we want to create is a form so the user can create movies cause we have nothing in the database right now 
	>> create a file named Form.js in the components folder

	>> what are the two things//HTML code that we always need to create a form? use the form tag and the 2 things it needs will be LABELS and INPUTS

	remember that every component needs a function, return, import, and export like so 

		import React from 'react'

		const Form = () => {
    			return(
        			<div>

        			</div>
    			)
		}

		export default Form


>> we will create this form using our Movie Schema inside our movie.model.js file 
[HIGHLIGHT - HOLD DOWN OPTION AND CLICK EVERY WORD YOU WANT TO EDIT AT THE SAME TIME]
	<form>
		<label>Title</label>
		<input type="text" />
		<button type="submit"> Create Movie </button>
	</form>



>> as we type data into this form.. we must make sure we bind all of these fields into state. so what do i need to do? 

4. import useState by adding it to line item one in the Form.js file
	import React, {useState} from 'react'

	now we need to define our states for each of the inputs in our form 
		const Form = () => {

    			const [title,setTitle] = useState('')
    			const [director,setDirector] = useState('')
    			const [rating,setRating] = useState('')
			...
	now we need to bind each of the states (because if we dont .. anything we type into these fields are not going to be stored right now) to their respective field in the form 
	we do this by using onChange in the input tag 

		<label>Title:</label>
                <input type ="text" onChange={(e)=>setTitle(e.target.value)} />

	// what is e? e is an event object - we get an event object every time an event occurs 
	// "target" == "this" -- this HTML tag that the event has happened on. 
	// value == the actual value that we are typing 

5. now we should test it out and see if everything is good so far.. remember that our project consists of two parts, the front end and the back end.. so youre going to want to start having two terminals up because we're going to be the ones running our server and our client 
	>> i like to have my client on the left 
	


	>> cd into client folder on one terminal and run.  (localhost:3000)
		npm start
	>> cd into server folder on second terminal and run 
		nodemon server.js


// why doesnt anything show up when we run the react app? because we havent added the route to app.js file yet or imported our Form component
	inside the app.js file
	
	>> <Route path="/" element={<Form />} />

//the path = the URL we are giving that specific route 
// the element = what we will render .. so we are saying here that we want to render our Form component

	now we need to import Form from our components folder.. if we type in the code above first and then import..
		we can type import F and the first option in the drop down press enter will give us the import statement so we dont have to type it out.

after we save the file the form should render on the page now. To make the form look a bit nicer we can use boot strap if we want to use boot strap we have too copy the cdn link and

BootStrap CDN Link -- we can paste this in
	>> CLIENT >> PUBLIC >> INDEX.HTML FILE 
inside the header somewhere and use bootstrap in our renders

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">



6. How can i check to make sure that my data binding is working?
	Google Chrome >> right click >> inspect tool >> components >> click on Form > and when we type we should see the words appearing under hooks


7. since we have specific rating and genres in our model .. we can change those items on the form into drop down/select menus 


*** two way binding mentioned by student... instructor says its more or less not important at this moment cause it will not break our code but will help us down the road.. 
	what this does is it maps the value in the field to whatever is in state so remember when we try and clear out the field we want to make sure its mapping so if we delete stuff that it shows up 
	we do this by adding value ={nameofinput} into the input type line like so
	<input type ="text" className="form-control" value={title} onChange={(e)=>setTitle(e.target.value)} />
***


BACK TO POINT 7 - so lets change our rating field which is currently an input field into a selection field 
we do this by using
<select> </select> and <option value=""></option>
and getting rid of the input type

like so...

	<select className="form-control" value={rating} onChange={(e)=>setRating(e.target.value)}>
                <option value="G">G</option>
                <option value="PG">PG</option>
                <option value="PG-13">PG-13</option>
                <option value="R">R</option>
                <option value="NC-17">NC-17</option>
        </select>



we need to do this for genre as well. and last thing is we need to change the input type from text to number for year so that it matches out model.js file.


8. now we are ready for our submit Handler -- so what are we doing with this data and where are we going to send it?
	>> we are trying to store it inside the database 

	a. first we need to say e.preventDefault to prevent the page from refreshing 
	b. then use axios to make a post request to our database so we need to import it at the top  // import axios from 'react'
		>> we need the URL from the server. and we need the object that youre going to send that mirrors the model
axios.post('THE URL', {the object we are mirroring }
	// remember in JS where we have a key and a value that are the same name we can just write them out one time 

        axios.post('http://localhost:8000/api/addMovie', {
            title:title,   //like here we are saying title = title but in our code again we only have to write it out one time.
            director:director, 
            rating, 
            genre, 
            releaseYear, 
            duration, 
            image
        })


// again we want to make sure that these fields match the names in our model soo recall that in the model i called the last field boxArt.. so to fix that i can either change the name image everywhere in my codes to boxArt OR i can write boxArt:image here 



	c. so because this is an axio request we dont know how long it will take to run that request so its a promise and we need to "HANDLE" that request by adding in our .then and .catch statements.

}).then((res)=>{
	console.log(res)
}).catch((err)=>{
	console.log(err)
})

	d. now that we are done with writing this function we need to add it to our form tag using onSubmit={submitHandler}


9. we need to add additional middleware to our server.js file so that the front end and back end can communicate with eachother

// test out 
for image go to the webpage right click and copy image address and paste here


//npm i cors needs to be installed inside the server folder and the following code needs to be added to the server.js file so that the front end and back end can communicate with one another
app.use(
    cors({
        origin: 'http://localhost:3000',
        }),
    );


10. now we want to be able to read/see everything from the db on one page and we are going to do this by creating a new component that has a list in it.

>> component name MovieList.js

11. In our app.js file we need to add in a new route 
          <Route path="/movielist" element={<MovieList />} />

	and we need to import MovieList from './components/MovieList'; at the top

	// next we go to our movielist.js component file and import react, useState, and useEffect

if i want to make a request to grab some data as soon as this component loads what might I use? 
useEffect 
and what kind of request am i making? where does my data live? 
we need to use axios to make a request 
need our .then and .catch because this is a promise and we need to handle our outcomes.. 

//what do we want to do with the data we get ?
we want to store the list of movies and stay in state

//check code. inside console in the inspect tool we should see data stored under data


so now we have successfully grabbed the data from the database we've stored it in state on our front end in our component so what do we need to do now to make sure that we actually see this on screen?


12. map the list 

	{
                list.map((movie)=>(

                    
                ))
        }

// so remember here that movie in parenthesis can be named ANYTHING bc its just representing what we are going to call each individual item in this list 




13. Now I want to make it so that when I submit the form it automatically takes me to the list of movies route to do this first we will import useNavigate to the form.js file
	import { useNavigate } from 'react-router-dom'


Then we will create a const navigate = useNavigate()



Then we will go to our submit handler and if our promise is successful in the handle we will add 
	navigate('/movielist')








//what is unique about nav link? Class active 
So we can go into our app.css and 
	.active{
 		 color: red;
	}
So whichever link is active should turn red.. its not working will fix next time


Issue was one of our routes was just a single slash. So 

Adding 

    let activeStyle ={
        colot: "red",
    };

And

<NavLink to="/movielist" className="m-3" style={({ isActive }) => isActive ? activeStyle : undefined}>Home</NavLink>
            <NavLink to="/form" style={({ isActive }) => isActive ? activeStyle : undefined}>Form</NavLink>

Into our navbar.js file fixes this issue

___________________________________________________________________________________________

10-05-22 Full stack day 3
[update and delete on front end]

1. we want to be able to view more detail about one movie when we click on the image or title of the movie from my home/list page how do we do that?

We will first create a new component for the data for one individual movie 
	>> OneMovie.js

Now we want to link from react-router-dom -- this will be coming from our movie list // movielist.js so what we are going to do is .. 

	// go into movielist.js and

	import { Link } from 'react-router-dom'
	
	
	
	then we are going to change the movie.title into a link 

<Link to="

Create a new route that will render the movie page inside app.js file 
	<Route path="/onemovie/:id element={MovieList />} />






2. Add delete function 





3. Add update function 

	>> we will create a new component called EditForm.js




































































____________________________________________________________________________________________


Everything stored in MongoDB is objects 
MondgoDB database - sql v























































